import typing
from pathlib import Path

import eccodes
import xarray as xr
from tqdm import tqdm

from nwpc_data.grib.eccodes._util import _check_message
from nwpc_data.grib.eccodes._xarray import create_xarray_array, get_level_coordinate_name


def load_field_from_file(
        file_path: str or Path,
        parameter: str or typing.Dict,
        level_type: str or typing.Dict,
        level: int or float or typing.List or None,
) -> xr.DataArray or None:
    """
    Load **one** field from local GRIB2 file using eccodes-python.
    Or load multi levels into one field.

    Parameters
    ----------
    file_path
    parameter
    level_type: str or typing.Dict
        level type. Use GRIB key `typeOfLevel`.
        If `typeOfLevel` is not available, use dict to specify filter conditions.
        For example, to get one filed from GRAPES GFS modelvar GRIB2 file, use:
            {
                "typeOfFirstFixedSurface": 131
            }
    level: int or float or typing.List or None
        level value. If use a scalar, level will be a non-dimension coordinate.
        If your want to extract multi levels, use a list and level will be a dimension (level, lat, lon).

    Returns
    -------
    DataArray or None:
        DataArray if found, or None if not.

    Examples
    --------
    Load 850hPa temperature field from a GRIB2 file generated by GRAPES GFS.

    >>> load_field_from_file(
    ...     file_path="/sstorage1/COMMONDATA/OPER/NWPC/GRAPES_GFS_GMF/Prod-grib/2020031721/ORIG/gmf.gra.2020031800105.grb2",
    ...     parameter="t",
    ...     level_type="isobaricInhPa",
    ...     level=850,
    ...     engine="eccodes",
    ... )
    <xarray.DataArray (latitude: 720, longitude: 1440)>
    array([[249.19234375, 249.16234375, 249.16234375, ..., 249.15234375,
            249.19234375, 249.14234375],
           [249.45234375, 249.45234375, 249.42234375, ..., 249.45234375,
            249.44234375, 249.44234375],
           [249.69234375, 249.68234375, 249.68234375, ..., 249.70234375,
            249.67234375, 249.68234375],
           ...,
           [235.33234375, 235.45234375, 235.62234375, ..., 235.47234375,
            235.63234375, 235.48234375],
           [235.78234375, 235.91234375, 235.64234375, ..., 235.80234375,
            235.72234375, 235.82234375],
           [235.66234375, 235.86234375, 235.82234375, ..., 235.85234375,
            235.68234375, 235.70234375]])
    Coordinates:
      * latitude   (latitude) float64 89.88 89.62 89.38 ... -89.38 -89.62 -89.88
      * longitude  (longitude) float64 0.0 0.25 0.5 0.75 ... 359.0 359.2 359.5 359.8
    Attributes:
        GRIB_edition:                    2
        GRIB_centre:                     babj
        GRIB_subCentre:                  0
        GRIB_tablesVersion:              4
        GRIB_localTablesVersion:         1
        GRIB_dataType:                   fc
        GRIB_dataDate:                   20200318
        GRIB_dataTime:                   0
        GRIB_step:                       105
        GRIB_stepType:                   instant
        GRIB_stepUnits:                  1
        GRIB_stepRange:                  105
        GRIB_name:                       Temperature
        GRIB_shortName:                  t
        GRIB_cfName:                     air_temperature
        GRIB_discipline:                 0
        GRIB_parameterCategory:          0
        GRIB_parameterNumber:            0
        GRIB_gridType:                   regular_ll
        GRIB_gridDefinitionDescription:  Latitude/longitude
        GRIB_typeOfFirstFixedSurface:    pl
        GRIB_typeOfLevel:                isobaricInhPa
        GRIB_level:                      850
        GRIB_numberOfPoints:             1036800
        GRIB_missingValue:               9999
        GRIB_units:                      K
        long_name:                       Temperature
        units:                           K

    """
    messages = []

    with open(file_path, "rb") as f:
        total_count = eccodes.codes_count_in_file(f)

    with open(file_path, "rb") as f:
        pbar = tqdm(
            total=total_count,
            desc="Filtering",
        )
        while True:
            message_id = eccodes.codes_grib_new_from_file(f)
            if message_id is None:
                break
            pbar.update(1)
            if not _check_message(message_id, parameter, level_type, level):
                eccodes.codes_release(message_id)
                continue
            messages.append(message_id)
            if isinstance(level, typing.List) or level is None:
                continue
            else:
                break
        pbar.close()

    if len(messages) == 0:
        return None

    if len(messages) == 1:
        message_id = messages[0]
        data = create_xarray_array(message_id)
        eccodes.codes_release(message_id)
        return data

    if len(messages) > 1:
        pbar = tqdm(
            total=len(messages),
            desc="Creating DataArrays",
        )

        def creat_array(message):
            array = create_xarray_array(message)
            pbar.update(1)
            return array

        xarray_messages = [creat_array(message) for message in messages]
        for m in messages:
            eccodes.codes_release(m)
        pbar.close()

        if isinstance(level_type, str):
            level_dim_name = level_type
        elif isinstance(level_type, typing.Dict):
            level_dim_name = get_level_coordinate_name(xarray_messages[0])
        else:
            raise ValueError(f"level_type is not supported: {level_type}")

        print("concat DataArrays...")
        data = xr.concat(xarray_messages, level_dim_name)
        return data

    return None


def load_field_from_files(
        file_list: typing.List,
        parameter: str or typing.Dict,
        level_type: str or typing.Dict,
        level: int or float or typing.List or None,
) -> xr.DataArray or None:
    field_list = []
    for file_path in file_list:
        print(file_path)
        field = load_field_from_file(
            file_path,
            parameter=parameter,
            level_type=level_type,
            level=level,
        )
        field_list.append(field)

    data_set = xr.combine_by_coords(
        [f.expand_dims(["time", "step"]).to_dataset() for f in field_list]
    )
    data = _load_first_variable(data_set)
    data = data.transpose("time", "step", ...)
    return data


def _load_first_variable(data_set: xr.Dataset) -> xr.DataArray:
    first_variable_name = list(data_set.data_vars)[0]
    return data_set[first_variable_name]
